// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/MasterService.h"
#include "gen-cpp/WorkerService.h"
#include "gen-cpp/SharedService.h"
#include "gen-cpp/MasterValidation.h"

#include "nlohmann/json.hpp"


//#include <thrift/server/TNonblockingServer.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
//#include <thrift/TFramedTransport.h>
#include <thrift/concurrency/Exception.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/transport/PlatformSocket.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
//#include <thrift/transport/TNonblockingServerTransport.h>
//#include <thrift/transport/TNonblockingServerSocket.h>
#include <thrift/TToString.h>

#include <iostream>
#include <exception>
#include <string>
#include <pthread.h>
#include <thread>
#include <cstdlib>
#include <vector>
//#include <random>
//#include <functional>
//include <algorithm>  
#include "Logger.h"

#include <execinfo.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

// to check directory exists
#include <sys/stat.h> 

#include <openssl/sha.h>
#include <sstream>
#include <iomanip>

#include "utils.h"

//#define NUM_WORKERS 5
//#define NUM_THREADS 5
//#define NUM_ACCOUNTS 50
//#define NUM_TRANSACTIONS 10
//#define RANDOM_SEED 10


using namespace std;

using json = nlohmann::json;

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::concurrency;
using namespace ::apache::thrift::server;

using namespace  ::MasterService;
using namespace  ::WorkerService;
using namespace  ::SharedService;
using namespace  ::MasterValidation;

Block block;
bool minerStatus = false;
string filename;
string dir_path;
string prevBlockHash = "0000000000000000000000000000000000000000000000000000000000000000";
string difficulty = "00011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111";


bool mining = false;

vector<WorkerNode> WorkerList;
vector<WorkerNode> ValWorkerList;

vector<Transaction> txnsList;

vector<Transaction> valTxnsList;


map<string,DataItem> dataItemMap;
map<int16_t, map<set<string>,set<int16_t>>> GlobalConflictsMap; // map<list<addresses>, list<txid>>
map<string,list<int16_t>> LocalConflictsMap; // map<address,list<txid>>

map<string,DataItem> valDataItemMap;
map<int16_t, map<set<string>,set<int16_t>>> valGlobalConflictsMap; // map<list<addresses>, list<txid>>
map<string,list<int16_t>> valLocalConflictsMap; // map<address,list<txid>>

map<string,DataItem> val2DataItemMap;



map<int16_t,std::vector<WorkerResponse>> GlobalWorkerResponsesList;

map<string,list<string>> AdjacencyMap;

map<int16_t,std::vector<WorkerResponse>> valGlobalWorkerResponsesList;

map<string,list<string>> valAdjacencyMap;




// object to store json ethereum blocks data
json ethereum_data;

int NUM_WORKERS = 5;
int NUM_THREADS = 5;

int masterPort = 10090;
string masterIP = "192.168.0.17";
//string masterIP = "localhost";

int masterPort2 = 11090;
string masterIP2 = "192.168.0.17";
//string masterIP2 = "localhost";

//pthread_t global_threads[10];

const string MSG="MasterServer";
const double base_reward = 3000000000000000000;

struct thread_data {
   int16_t  threadID;
   int16_t workerID;
   string workerIP;
   int32_t workerPort;
   //string miner;
   int number;
};


// Global Data Structures used by multiple functions

map<int16_t,vector<Transaction>> sendTransactionMap;
map<int16_t, set<int16_t>> ccTransactionMap;
set<string> contractAddresses;


map<int16_t,vector<Transaction>> valSendTransactionMap;
map<int16_t, set<int16_t>> valccTransactionMap;
set<string> valContractAddresses;
set<string> val2ContractAddresses;



string convert_block_to_string(Block block) {
  stringstream ss;
  ss << block.number << block.prevHash << block.nonce; //<< block.transactionsList;
  for (auto& tx : block.transactionsList) {
    ss << tx.transactionID;
    ss << tx.toAddress;
    ss << tx.fromAddress;
    ss << tx.value;
    ss << tx.input;
    ss << tx.creates;
    //str.append(to_string(tx.gas));
    //str.append(to_string(tx.gasPrice));
  }
  return ss.str();
}


void createBlock(json::iterator data) {
  //Logger::instance().log(MSG+" Block "+to_string(block.number)+" creation starts", Logger::kLogLevelInfo);
  //block.number = index++;stoi(data.key());//atoi(d.key().c_str());
  
  //Logger::instance().log(MSG+" Block "+to_string(block.number)+" transactionsList starts", Logger::kLogLevelInfo);
  int16_t txid=0;
  for (auto& tx: (*data)["transactions"]) {
    Transaction transaction;
    transaction.transactionID = txid++; //tx["txID"];
    transaction.fromAddress = tx["from"];
    transaction.toAddress = tx["to"];
    transaction.value = tx["value"].get<double>();
    transaction.input = tx["input"];
    transaction.creates = tx["creates"]; 
    block.transactionsList.push_back(transaction);
  }
  //Logger::instance().log(MSG+" Block "+to_string(block.number)+" transactionsList ends", Logger::kLogLevelInfo);

  //Logger::instance().log(MSG+" Block "+to_string(block.number)+" creation ends", Logger::kLogLevelInfo);
}

// Clears memory of global data structures after every block creation
void clear_memory_miner() {
  sendTransactionMap.clear();
  ccTransactionMap.clear();
  GlobalConflictsMap.clear();
  LocalConflictsMap.clear();
  GlobalWorkerResponsesList.clear();
  AdjacencyMap.clear();
  block.transactionsList.clear();
  block.finalDataItemMap.clear();
  block.sendTxnMap.clear();
  txnsList.clear();
}

void clear_memory_val() {
  valSendTransactionMap.clear();
  valccTransactionMap.clear();
  valGlobalConflictsMap.clear();
  valLocalConflictsMap.clear();
  valGlobalWorkerResponsesList.clear();
  valAdjacencyMap.clear();
  block.transactionsList.clear();
  block.finalDataItemMap.clear();
  block.sendTxnMap.clear();
  valTxnsList.clear();
} 



// Recursive DFS to find all connected components
void DFSUtil (int ccID, string v, map<string,bool> &visited) {
  // Mark the current node as visited and print it
  visited[v] = true;
  for (auto const& tx: LocalConflictsMap[v])
    ccTransactionMap[ccID].insert(tx);
  // Recur for all vertices
  // adjacent to this vertex
  
  for (auto const& vc: AdjacencyMap[v]) {
    if (visited[vc] == false) {
      DFSUtil(ccID,vc,visited);
    }
  }
}



// Creates graph and starts search for identifying connected components
// Connected components are considered as dependent transactions club together
// and are executed serially on the workers
void analyze(vector<Transaction> TransactionList) {
  std::set<string> AddressList;
  for (auto const& tx: TransactionList) {
    txnsList.push_back(tx);
    LocalConflictsMap[tx.fromAddress].push_back(tx.transactionID);
    if (tx.toAddress == "creates") {
      LocalConflictsMap[tx.creates].push_back(tx.transactionID);
      AdjacencyMap[tx.creates].push_back(tx.fromAddress); 
      AddressList.insert(tx.creates);
      AdjacencyMap[tx.fromAddress].push_back(tx.creates);
    } else {
      LocalConflictsMap[tx.toAddress].push_back(tx.transactionID);
      AdjacencyMap[tx.toAddress].push_back(tx.fromAddress);
      AddressList.insert(tx.toAddress);
      AdjacencyMap[tx.fromAddress].push_back(tx.toAddress);
    }
    
    AddressList.insert(tx.fromAddress);
    
  }

  map<string,bool> visited;

  for (auto const& address: AddressList) {
    visited[address] = false;
  }

  int ccID = 1;
  int id = 0;
  int minID = 0;

  for (auto const& address: AddressList) {
    if (visited[address] == false) {
      DFSUtil(ccID,address,visited);
      
      if (ccTransactionMap[ccID].size() > 0) {
        for (auto const& txid: ccTransactionMap[ccID]) {
         sendTransactionMap[WorkerList[id].workerID].push_back(TransactionList[txid]);
        }
	
	

        if (ccID >= 5) {
          map<int16_t,vector<Transaction>>::iterator it1;
          map<int16_t,vector<Transaction>>::iterator it2;
          for (it1 = sendTransactionMap.begin(); it1 != sendTransactionMap.end(); ++it1)
          {
            for (it2 = sendTransactionMap.begin() ; it2 != sendTransactionMap.end(); ++it2)
            {
              if (it1->second.size() > it2->second.size()) {
                id = it2->first - 1;
              }
            }
          }
        } else {
          id = (id+1)%NUM_WORKERS;
        }

        ccID++;
      }
    }
  }
}


void valDFSUtil (int ccID, string v, map<string,bool> &visited) {
  // Mark the current node as visited and print it
  visited[v] = true;
  for (auto const& tx: valLocalConflictsMap[v])
    valccTransactionMap[ccID].insert(tx);
  // Recur for all vertices
  // adjacent to this vertex
  
  for (auto const& vc: valAdjacencyMap[v]) {
    if (visited[vc] == false) {
      valDFSUtil(ccID,vc,visited);
    }
  }
}




void valAnalyze(vector<Transaction> TransactionList) {
  std::set<string> AddressList;
  for (auto const& tx: TransactionList) {
    valTxnsList.push_back(tx);
    valLocalConflictsMap[tx.fromAddress].push_back(tx.transactionID);
    if (tx.toAddress == "creates") {
      valLocalConflictsMap[tx.creates].push_back(tx.transactionID);
      valAdjacencyMap[tx.creates].push_back(tx.fromAddress); 
      AddressList.insert(tx.creates);
      valAdjacencyMap[tx.fromAddress].push_back(tx.creates);
    } else {
      valLocalConflictsMap[tx.toAddress].push_back(tx.transactionID);
      valAdjacencyMap[tx.toAddress].push_back(tx.fromAddress);
      AddressList.insert(tx.toAddress);
      valAdjacencyMap[tx.fromAddress].push_back(tx.toAddress);
    }
    
    AddressList.insert(tx.fromAddress);
    
  }

  map<string,bool> visited;

  for (auto const& address: AddressList) {
    visited[address] = false;
  }

  int ccID = 1;
  int id = 0;
  int minID = 0;

  for (auto const& address: AddressList) {
    if (visited[address] == false) {
      valDFSUtil(ccID,address,visited);
      
      if (valccTransactionMap[ccID].size() > 0) {
        for (auto const& txid: ccTransactionMap[ccID]) {
         valSendTransactionMap[WorkerList[id].workerID].push_back(TransactionList[txid]);
        }
	
	

        if (ccID >= 5) {
          map<int16_t,vector<Transaction>>::iterator it1;
          map<int16_t,vector<Transaction>>::iterator it2;
          for (it1 = valSendTransactionMap.begin(); it1 != valSendTransactionMap.end(); ++it1)
          {
            for (it2 = valSendTransactionMap.begin() ; it2 != valSendTransactionMap.end(); ++it2)
            {
              if (it1->second.size() > it2->second.size()) {
                id = it2->first - 1;
              }
            }
          }
        } else {
          id = (id+1)%NUM_WORKERS;
        }

        ccID++;
      }
    }
  }
}







/*
bool fileExists(const std::string& file) {
    struct stat buf;
    return (stat(file.c_str(), &buf) == 0);
}
*/

// multi threaded function call to spin parallel connection to each worker from master

void *connectWorker (void *threadarg) {
  //map< string,double> LocalDataItemMap;
  

  struct thread_data *worker;
  worker = (struct thread_data *) threadarg;

  Logger::instance().log(MSG+" Block "+to_string(worker->number) +" thread "+ to_string(worker->workerID) +" starts", Logger::kLogLevelInfo);
      
	/*
  std::shared_ptr<TTransport> socket(new TSocket(worker->workerIP, worker->workerPort));
  std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
  WorkerServiceClient workerClient(protocol);

  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" connection to worker "+to_string(worker->workerID)+" starts", Logger::kLogLevelInfo);
  transport->open();
	*/
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" localDataItemMap generation for worker "+to_string(worker->workerID)+" starts", Logger::kLogLevelInfo);
  
  // Creates data items map of address which are going to be modified by the transactions sent to worker
  // instead of sending complete map of addresses

  map<string,DataItem> localDataItemMap;
  for (auto& tx: sendTransactionMap[worker->workerID]) {
    // add code to get the current state of contract  

    localDataItemMap[tx.fromAddress] = dataItemMap[tx.fromAddress];
    localDataItemMap[tx.toAddress] = dataItemMap[tx.toAddress];


  }


  std::shared_ptr<TTransport> socket(new TSocket(worker->workerIP, worker->workerPort));
  std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
  WorkerServiceClient workerClient(protocol);

  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" connection to worker "+to_string(worker->workerID)+" starts", Logger::kLogLevelInfo);
    transport->open();


  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" localDataItemMap generation for worker "+to_string(worker->workerID)+" ends", Logger::kLogLevelInfo);
  
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" WorkerID "+to_string(worker->workerID)+" recvTransactions() starts", Logger::kLogLevelInfo);

  WorkerResponse localWorkerResponse;
  try{
  	workerClient.recvTransactions(localWorkerResponse,sendTransactionMap[worker->workerID],localDataItemMap, contractAddresses); // returns local worker response
  } catch (exception& e)
  {
    cout << "Error in connect worker" << e.what()  << '\n';
  }
  cout << worker->threadID << ":" << sendTransactionMap[worker->workerID].size() << ":" << localWorkerResponse.dataItemMap.size() << "\n";
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" WorkerID "+to_string(worker->workerID)+" recvTransactions() ends", Logger::kLogLevelInfo);
  transport->close();

  //cout << "WR dataItemMap" << endl;
  for (auto it :localWorkerResponse.dataItemMap)
  {
    dataItemMap[it.first] = it.second;
  }
  //cout << "WR txnsList" << endl;
/*
  for (auto it : localWorkerResponse.transactionIDList) {
    //cout << "txid: " << it << endl;
    block.transactionsList.push_back(txnsList[it]);
  }
*/
  //cout << "WR cntrctAddr" << endl;
  for (auto it :localWorkerResponse.contractAddresses)
  {
    contractAddresses.insert(it);
  }

 // transport->close();
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" connection to worker "+to_string(worker->workerID)+" ends", Logger::kLogLevelInfo);
  Logger::instance().log(MSG+" Block "+to_string(worker->number) +" thread "+ to_string(worker->workerID) +" ends", Logger::kLogLevelInfo);
      

  delete worker;

  pthread_exit(&worker->threadID);
}



void *connectValWorker (void *threadarg) {
  //map< string,double> LocalDataItemMap;
  

  struct thread_data *worker;
  worker = (struct thread_data *) threadarg;

  Logger::instance().log(MSG+" Block "+to_string(worker->number) +" val_thread "+ to_string(worker->workerID) +" starts", Logger::kLogLevelInfo);
      
	/*
  std::shared_ptr<TTransport> socket(new TSocket(worker->workerIP, worker->workerPort));
  std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
  WorkerServiceClient workerClient(protocol);

  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" connection to worker "+to_string(worker->workerID)+" starts", Logger::kLogLevelInfo);
  transport->open();
	*/
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" localDataItemMap generation for worker "+to_string(worker->workerID)+" starts", Logger::kLogLevelInfo);
  
  // Creates data items map of address which are going to be modified by the transactions sent to worker
  // instead of sending complete map of addresses

  map<string,DataItem> localDataItemMap;
  for (auto& tx: valSendTransactionMap[worker->workerID]) {
    // add code to get the current state of contract  

    localDataItemMap[tx.fromAddress] = valDataItemMap[tx.fromAddress];
    localDataItemMap[tx.toAddress] = valDataItemMap[tx.toAddress];


  }


  std::shared_ptr<TTransport> socket(new TSocket(worker->workerIP, worker->workerPort));
  std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
  WorkerServiceClient workerClient(protocol);

  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" connection to worker "+to_string(worker->workerID)+" starts", Logger::kLogLevelInfo);
    transport->open();


  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" localDataItemMap generation for worker "+to_string(worker->workerID)+" ends", Logger::kLogLevelInfo);
  
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" WorkerID "+to_string(worker->workerID)+" recvTransactions() starts", Logger::kLogLevelInfo);

  WorkerResponse localWorkerResponse;
  try{
  	workerClient.recvValTransactions(localWorkerResponse,valSendTransactionMap[worker->workerID],localDataItemMap, valContractAddresses); // returns local worker response
  } catch (exception& e)
  {
    cout << "Error in connect val worker" << e.what()  << '\n';
  }
  cout << worker->threadID << ":" << valSendTransactionMap[worker->workerID].size() << ":" << localWorkerResponse.dataItemMap.size() << "\n";
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" WorkerID "+to_string(worker->workerID)+" recvTransactions() ends", Logger::kLogLevelInfo);
  transport->close();

  //cout << "WR dataItemMap" << endl;
  for (auto it :localWorkerResponse.dataItemMap)
  {
    valDataItemMap[it.first] = it.second;
  }
  //cout << "WR txnsList" << endl;
/*
  for (auto it : localWorkerResponse.transactionIDList) {
    //cout << "txid: " << it << endl;
    block.transactionsList.push_back(txnsList[it]);
  }
*/
  //cout << "WR cntrctAddr" << endl;
  for (auto it :localWorkerResponse.contractAddresses)
  {
    valContractAddresses.insert(it);
  }

 // transport->close();
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" connection to worker "+to_string(worker->workerID)+" ends", Logger::kLogLevelInfo);
  Logger::instance().log(MSG+" Block "+to_string(worker->number) +" val_thread "+ to_string(worker->workerID) +" ends", Logger::kLogLevelInfo);
      

  delete worker;

  pthread_exit(&worker->threadID);
}


void *connectVal2Worker (void *threadarg) {
  //map< string,double> LocalDataItemMap;
  

  struct thread_data *worker;
  worker = (struct thread_data *) threadarg;

  Logger::instance().log(MSG+" Block "+to_string(worker->number) +" val2_thread "+ to_string(worker->workerID) +" starts", Logger::kLogLevelInfo);
      
	/*
  std::shared_ptr<TTransport> socket(new TSocket(worker->workerIP, worker->workerPort));
  std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
  WorkerServiceClient workerClient(protocol);

  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" connection to worker "+to_string(worker->workerID)+" starts", Logger::kLogLevelInfo);
  transport->open();
	*/
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" localDataItemMap generation for worker "+to_string(worker->workerID)+" starts", Logger::kLogLevelInfo);
  
  // Creates data items map of address which are going to be modified by the transactions sent to worker
  // instead of sending complete map of addresses

  map<string,DataItem> localDataItemMap;
  for (auto& tx: sendTransactionMap[worker->workerID]) {
    // add code to get the current state of contract  

    localDataItemMap[tx.fromAddress] = val2DataItemMap[tx.fromAddress];
    localDataItemMap[tx.toAddress] = val2DataItemMap[tx.toAddress];


  }


  std::shared_ptr<TTransport> socket(new TSocket(worker->workerIP, worker->workerPort));
  std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
  WorkerServiceClient workerClient(protocol);

  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" connection to worker "+to_string(worker->workerID)+" starts", Logger::kLogLevelInfo);
    transport->open();


  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" localDataItemMap generation for worker "+to_string(worker->workerID)+" ends", Logger::kLogLevelInfo);
  
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" WorkerID "+to_string(worker->workerID)+" recvTransactions() starts", Logger::kLogLevelInfo);

  WorkerResponse localWorkerResponse;
  try{
  	workerClient.recvVal2Transactions(localWorkerResponse,sendTransactionMap[worker->workerID],localDataItemMap, val2ContractAddresses); // returns local worker response
  } catch (exception& e)
  {
    cout << "Error in connect val worker" << e.what()  << '\n';
  }
  cout << worker->threadID << ":" << sendTransactionMap[worker->workerID].size() << ":" << localWorkerResponse.dataItemMap.size() << "\n";
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" WorkerID "+to_string(worker->workerID)+" recvTransactions() ends", Logger::kLogLevelInfo);
  transport->close();

  //cout << "WR dataItemMap" << endl;
  for (auto it :localWorkerResponse.dataItemMap)
  {
    val2DataItemMap[it.first] = it.second;
  }
  //cout << "WR txnsList" << endl;
/*
  for (auto it : localWorkerResponse.transactionIDList) {
    //cout << "txid: " << it << endl;
    block.transactionsList.push_back(txnsList[it]);
  }
*/
  //cout << "WR cntrctAddr" << endl;
  for (auto it :localWorkerResponse.contractAddresses)
  {
    val2ContractAddresses.insert(it);
  }

 // transport->close();
  //Logger::instance().log(MSG+" Block "+to_string(worker->number) +" connection to worker "+to_string(worker->workerID)+" ends", Logger::kLogLevelInfo);
  Logger::instance().log(MSG+" Block "+to_string(worker->number) +" val2_thread "+ to_string(worker->workerID) +" ends", Logger::kLogLevelInfo);
      

  delete worker;

  pthread_exit(&worker->threadID);
}





class MasterServiceHandler : virtual public MasterServiceIf {
 public:
  MasterServiceHandler() {
    // Your initialization goes here
    
    int16_t port = 8091;
    string ip = "192.168.0.";
    //string ip = "localhost";

    //vector<string> masterIPList;

    //int wip = 12;
    int wip[5] = {13,14,15,16,34};
    for (int16_t id=1; id<=NUM_WORKERS; id++) {
      WorkerNode workerNode;
      workerNode.workerID = id;
      workerNode.workerIP = ip + to_string(wip[id-1]);
      workerNode.workerPort = port++;

      WorkerList.push_back(workerNode);
      //wip++;
    }

    //Logger::instance().log(MSG+" Initializing accounts with 100000000000000000000000 wei to execute transactions starts", Logger::kLogLevelInfo);
    
    string line;
    ifstream accounts_file ("data/bigquery/addresses.json");
    //ifstream dataItem_file ("data/bigquery/dataItems.json");
    json accounts;
    accounts_file >> accounts;
    cout << "accounts size " << accounts.size() << endl;
    // iterate the array
    for (json::iterator it = accounts.begin(); it != accounts.end(); ++it) {
      if (it.value().get<double>() != 0)
        dataItemMap[it.key()].value =  it.value().get<double>();
	valDataItemMap[it.key()].value =  it.value().get<double>();
	val2DataItemMap[it.key()].value =  it.value().get<double>();
    }
    cout << "optimized accounts size " << dataItemMap.size() << endl;
    
    //Logger::instance().log(MSG+" Initializing accounts with 100000000000000000000000 wei to execute transactions ends", Logger::kLogLevelInfo);
    
    std::ifstream ethereum_data_file(filename);
    ethereum_data_file >> ethereum_data;    

    
    
  }

  // process block received from masterClient

  void processBlocks() {
    // open a file in write mode.
    ofstream e2efile;
    e2efile.open(dir_path+"be_e2e.csv",std::ofstream::out | std::ofstream::trunc);
      
    ofstream txnfile;
    txnfile.open(dir_path+"be_txn.csv",std::ofstream::out | std::ofstream::trunc);
    
    ofstream minefile;
    minefile.open(dir_path+"be_mine.csv",std::ofstream::out | std::ofstream::trunc);  

    ofstream valfile;
    valfile.open(dir_path+"be_val.csv",std::ofstream::out | std::ofstream::trunc); 
    
    ofstream val2file;
    val2file.open(dir_path+"be_val2.csv",std::ofstream::out | std::ofstream::trunc); 
   
    ofstream tcfile;
    tcfile.open(dir_path+"be_txns_count.csv",std::ofstream::out | std::ofstream::trunc);
 
    // Your implementation goes here
    int64_t index = 0;
    for (json::iterator data = ethereum_data.begin(); data != ethereum_data.end(); ++data) {
      
      //
      /**
      ofstream prevState;
      if (NUM_WORKERS == 1)
        prevState.open("state/"+to_string(NUM_WORKERS)+"_worker/block_"+to_string(block.number)+"_prev_state.csv",std::ofstream::out | std::ofstream::trunc);
      else 
        prevState.open("state/"+to_string(NUM_WORKERS)+"_workers/block_"+to_string(block.number)+"_prev_state.csv",std::ofstream::out | std::ofstream::trunc);
      prevState.close();
      */
      auto start = chrono::steady_clock::now();
      block.number = index++;
      block.prevHash = prevBlockHash;
      block.nonce = 0;
      if (block.number > 100 and mining) break;

      createBlock(data);
      

      //if (block.number >= 5) break;
      cout << block.number << "\t" << block.transactionsList.size() << "\n";
      tcfile << block.number << ","<< block.transactionsList.size();
      
      
      // miner status set to false for each block
      // it is to stop mining once solution is found
      minerStatus = false;
      double uncle_reward = 0;

      if (block.transactionsList.size() > 0) {
        Logger::instance().log(MSG+" Block "+to_string(block.number)+" analyze starts", Logger::kLogLevelInfo);
        //sendTransactionMap.clear();
        analyze(block.transactionsList);
        Logger::instance().log(MSG+" Block "+to_string(block.number)+" analyze ends", Logger::kLogLevelInfo);
	
	/*
	for (auto tx: block.transactionsList) {
        	cout << "txid:" << tx.transactionID << ",from:" << tx.fromAddress << ",to:" << tx.toAddress << ",value:" 
                                << tx.value << ",input:" << tx.input << ",creates:" << tx.creates << endl;
        }


	for (auto it : sendTransactionMap) {
		cout << it.first << " " << it.second.size() << endl;
		for (auto tx: it.second) {
			cout << "txid:" << tx.transactionID << ",from:" << tx.fromAddress << ",to:" << tx.toAddress << ",value:" 
				<< tx.value << ",input:" << tx.input << ",creates:" << tx.creates << endl; 
		}
		cout << endl;
	}
	exit(-1);
	*/
	//block.transactionsList.clear();

        //sendTransactions
        
        pthread_t threads[NUM_THREADS];
        pthread_attr_t attr;
        //struct thread_data td[NUM_THREADS];
        //struct thread_data *td = new(nothrow) struct thread_data[NUM_THREADS];
        int rc;
        int thID = 0;
        void *status;

        // Initialize and set thread joinable
        pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

        for (auto const& worker : WorkerList) {
	  //pthread_t threads;
	  struct thread_data *td = new(nothrow) struct thread_data;
          td->threadID = thID;
          td->workerID = worker.workerID;
          td->workerIP = worker.workerIP;
          td->workerPort = worker.workerPort;
          td->number = block.number;

          Logger::instance().log(MSG+" Block "+to_string(block.number)+" thread " + to_string(thID) +" starts", Logger::kLogLevelInfo); 
          rc = pthread_create(&threads[thID], &attr, connectWorker, (void *)td);
          tcfile << "," << sendTransactionMap[worker.workerID].size();
          if (rc) {
	     cout << "MS create failed" << endl;
             exit(-1);
          }
          thID = (thID+1) % NUM_THREADS;
        }
        
        // free attribute and wait for the other threads
        pthread_attr_destroy(&attr);
        
        for(int p = 0; p < NUM_THREADS; p++ ) {
          rc = pthread_join(threads[p], &status);
          if (rc) {
	     cout << "MS join failed" << endl;
             exit(-1);
          }
          //Logger::instance().log(MSG+" Block "+to_string(block.number)+" thread " + to_string(td[thID].threadID) +" ends", Logger::kLogLevelInfo);
        }                                                                                                                                                                           
      }

      auto end2 = chrono::steady_clock::now();
      txnfile << chrono::duration_cast<chrono::microseconds>(end2 - start).count() << "\n";
      //txnfile.close();

      tcfile << endl;

      //cout << "txns size: " << block.transactionsList.size() << endl;

      //block.finalDataItemMap = dataItemMap;
      //cout << "block dataItemMap size: " << block.finalDataItemMap.size() << endl;
      //block.sendTxnMap = sendTransactionMap;
      //cout << "block sendTxnMap size: " << block.sendTxnMap.size() << endl;


      //Block prevBlock;
      // Mining starts
      if (mining) {
        //Logger::instance().log(MSG+" Block " + to_string(block.number) + " Block Mining starts", Logger::kLogLevelInfo);
        minerStatus = false;
        //string block_hash = "0000000000000000000000000000000000000000000000000000000000000000";
        cout << mining << endl;
        //string block_str = convert_block_to_string(prevBlock);
        //block.prevHash = sha256(block_str);
        //cout << "prev hash calculated" << endl;
        cout << "Miner mineBlock starts" << endl;
        
	//bool[] flag = {0,0,0,0,0};
	//while (!flag) {
	//int count = 0;
        for (auto const& worker : WorkerList) {
	  //if (miningStatus) break;
	  //cout << worker.workerIP << " " << worker.workerPort << endl;
        //cout << "Miner mineBlock starts" << endl;  
        //int count = 0;
	//while(1) {
	 //count++;
	 //cout << "trying to send"
	  try {
	  std::shared_ptr<TTransport> socket(new TSocket(worker.workerIP, worker.workerPort));
          std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
          std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
          WorkerServiceClient workerClient(protocol);
          //Logger::instance().log(MSG+" Block "+to_string(block.number) +" connection to worker "+to_string(worker.workerID)+" starts", Logger::kLogLevelInfo);
          transport->open();
		
          //Logger::instance().log(MSG+" Block "+to_string(block.number) +" WorkerID "+to_string(worker.workerID)+" mineBlock() starts", Logger::kLogLevelInfo);
          //printf("Sending transactionsList and LocalDataItemsMap to worker nodes\n");
          //cout << "Miner mineBlock count:" << count << endl;
          workerClient.mineBlock(block,worker.workerID,NUM_WORKERS); // returns local worker response
          //Logger::instance().log(MSG+" Block "+to_string(block.number) +" WorkerID "+to_string(worker.workerID)+" mineBlock() ends", Logger::kLogLevelInfo);
          //std::this_thread::sleep_for(std::chrono::milliseconds(200));
          transport->close();
	  //cout << "Miner mineBlock ends" << endl;
	  //break;
	  //std::this_thread::sleep_for(std::chrono::milliseconds(100));
	} catch (exception& e) {
        	cout << "Mining Error: " << e.what() << endl;
           }
	}
	
	//cout << "Miner Block ends"
	//std::this_thread::sleep_for(std::chrono::milliseconds(200));
        //
          //Logger::instance().log(MSG+" Block "+to_string(block.number) +" connection to worker "+to_string(worker.workerID)+" ends", Logger::kLogLevelInfo);
          //Logger::instance().log(MSG+" Block "+to_string(newBlock.number) +" thread "+ to_string(worker.workerID) +" ends", Logger::kLogLevelInfo);
        //}
        //cout << "waiting starts" <<  endl;

	cout << "Mining Block ends" << endl;

        cout << endl;
	cout << "waiting" << endl;
        while (!minerStatus) {
	  cout << "waiting";
          cout << minerStatus;
          //bool status = minerStatus;
          //sleep(1);
          std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
	cout << "waiting ends" << endl;
        cout << endl;

        //Logger::instance().log(MSG+" Block " + to_string(block.number) + " Block Mining ends", Logger::kLogLevelInfo);

      }
      //cout << "waiting ends" << endl;
      //prevBlock = block;

      auto end3 = chrono::steady_clock::now();
      minefile << chrono::duration_cast<chrono::microseconds>(end3 - end2).count() << "\n";
      //txnfile.close();
      


      for (auto tx: block.transactionsList) {
	block.finalDataItemMap[tx.fromAddress] = dataItemMap[tx.fromAddress];
	block.finalDataItemMap[tx.toAddress] = dataItemMap[tx.toAddress];
	//block.finalDataItemMap[tx.creates] = dataItemMap[tx.creates];
      }
      //block.finalDataItemMap = dataItemMap;
      //cout << "block dataItemMap size: " << block.finalDataItemMap.size() << endl;
	
      for (auto it: sendTransactionMap) {
	for (auto tx : it.second) {
		block.sendTxnMap[it.first].push_back(tx.transactionID);
	}
	}
	
      //block.sendTxnMap = sendTransactionMap;
      //cout << "block sendTxnMap size: " << block.sendTxnMap.size() << endl;


      //Logger::instance().log(MSG+" Block "+to_string(block.number)+" clear_memory starts", Logger::kLogLevelInfo);
      //Logger::instance().log(MSG+" Block "+to_string(block.number)+" clear_memory ends", Logger::kLogLevelInfo);

      auto end4 = chrono::steady_clock::now();
      e2efile << chrono::duration_cast<chrono::microseconds>(end4 - start).count() << "\n";



      // validation without sharing info starts
      cout << endl << endl;
      cout << "validation without sharing info starts" << endl;
      cout << block.number << "\t" << block.transactionsList.size() << "\n";
      //tcfile << block.number << ","<< block.transactionsList.size();
      
      
      // miner status set to false for each block
      // it is to stop mining once solution is found
      //minerStatus = false;
      //double uncle_reward = 0;

      if (block.transactionsList.size() > 0) {
        Logger::instance().log(MSG+" Block "+to_string(block.number)+" valAnalyze starts", Logger::kLogLevelInfo);
        //sendTransactionMap.clear();
        valAnalyze(block.transactionsList);
        Logger::instance().log(MSG+" Block "+to_string(block.number)+" valAnalyze ends", Logger::kLogLevelInfo);
	
	/*
	for (auto tx: block.transactionsList) {
        	cout << "txid:" << tx.transactionID << ",from:" << tx.fromAddress << ",to:" << tx.toAddress << ",value:" 
                                << tx.value << ",input:" << tx.input << ",creates:" << tx.creates << endl;
        }


	for (auto it : sendTransactionMap) {
		cout << it.first << " " << it.second.size() << endl;
		for (auto tx: it.second) {
			cout << "txid:" << tx.transactionID << ",from:" << tx.fromAddress << ",to:" << tx.toAddress << ",value:" 
				<< tx.value << ",input:" << tx.input << ",creates:" << tx.creates << endl; 
		}
		cout << endl;
	}
	exit(-1);
	*/
	//block.transactionsList.clear();

        //sendTransactions
        
        pthread_t threads[NUM_THREADS];
        pthread_attr_t attr;
        //struct thread_data td[NUM_THREADS];
        //struct thread_data *td = new(nothrow) struct thread_data[NUM_THREADS];
        int rc;
	int thID = 0;
	void *status;

        // Initialize and set thread joinable
        pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

        for (auto const& worker : WorkerList) {
	  //pthread_t threads;
	  struct thread_data *td = new(nothrow) struct thread_data;
          td->threadID = thID;
          td->workerID = worker.workerID;
          td->workerIP = worker.workerIP;
          td->workerPort = worker.workerPort;
          td->number = block.number;

          Logger::instance().log(MSG+" Block "+to_string(block.number)+" val_thread " + to_string(thID) +" starts", Logger::kLogLevelInfo); 
          rc = pthread_create(&threads[thID], &attr, connectValWorker, (void *)td);
          //tcfile << "," << valSendTransactionMap[worker.workerID].size();
          if (rc) {
	     cout << "MS create failed" << endl;
             exit(-1);
          }
          thID = (thID+1) % NUM_THREADS;
        }
        
        // free attribute and wait for the other threads
        pthread_attr_destroy(&attr);
        
        for(int p = 0; p < NUM_THREADS; p++ ) {
          rc = pthread_join(threads[p], &status);
          if (rc) {
	     cout << "MS join failed" << endl;
             exit(-1);
          }
          //Logger::instance().log(MSG+" Block "+to_string(block.number)+" thread " + to_string(td[thID].threadID) +" ends", Logger::kLogLevelInfo);
        }                                                                                                                                                                           
      }

      bool blockStatus = true;
      for (auto it :block.finalDataItemMap)
      {
        if (valDataItemMap.find(it.first) != valDataItemMap.end()) {
                if (valDataItemMap[it.first].value != it.second.value) {
                        blockStatus = false;
			cout << valDataItemMap[it.first].value <<  " " << it.second.value << endl;
			break;
                }
        } else {
                cout << "val key not found" << endl;
        }

      }


      auto end5 = chrono::steady_clock::now();
      valfile << chrono::duration_cast<chrono::microseconds>(end5 - end4).count() << "\n";
      //txnfile.close();

      //tcfile << endl;

      //cout << "txns size: " << block.transactionsList.size() << endl;

      //block.finalDataItemMap = dataItemMap;
      //cout << "block dataItemMap size: " << block.finalDataItemMap.size() << endl;
      //block.sendTxnMap = sendTransactionMap;
      //cout << "block sendTxnMap size: " << block.sendTxnMap.size() << endl;

      // validation without sharing info starts
      cout << endl << endl;
      cout << "validation with sharing info starts" << endl;
      cout << block.number << "\t" << block.transactionsList.size() << "\n";

      if (block.transactionsList.size() > 0) {

        //sendTransactions
        //cout << "txn exe starts" << endl;
        
        pthread_t threads[NUM_THREADS];
        pthread_attr_t attr;
        //struct thread_data td[NUM_THREADS];
        int rc;
        int thID = 0;
        void *status;

        // Initialize and set thread joinable
        pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

        for (auto const& worker : WorkerList) {
	  struct thread_data *td = new(nothrow) struct thread_data;
          td->threadID = thID;
          td->workerID = worker.workerID;
          td->workerIP = worker.workerIP;
          td->workerPort = worker.workerPort;
          td->number = block.number;

          Logger::instance().log(MSG+" Block "+to_string(block.number)+" thread " + to_string(thID) +" starts", Logger::kLogLevelInfo); 
          rc = pthread_create(&threads[thID], &attr, connectVal2Worker, (void *)td);
          
          if (rc) {
	     cout << "create failed val2" << endl;
             exit(-1);
          }
          thID = (thID+1) % NUM_THREADS;
        }
        
        // free attribute and wait for the other threads
        pthread_attr_destroy(&attr);
        
        for(int p = 0; p < NUM_THREADS; p++ ) {
          rc = pthread_join(threads[p], &status);
          if (rc) {
             cout << "join failed val2" << endl;
             exit(-1);
          }
          //Logger::instance().log(MSG+" Block "+to_string(block.number)+" thread " + to_string(td->threadID) +" ends", Logger::kLogLevelInfo);
        }                                                                                                                                                                           
      }

      //cout << "txn exe ends" << endl;
      //auto end2 = chrono::steady_clock::now();
      //txnfile << chrono::duration_cast<chrono::microseconds>(end2 - start).count() << "\n";
      //txnfile.close();

      //cout << "validation starts" << endl;
	
      // verifying dataItemMap
      blockStatus = true;

      for (auto it :block.finalDataItemMap)
      {
        if (val2DataItemMap.find(it.first) != val2DataItemMap.end()) {
                if (val2DataItemMap[it.first].value != it.second.value) {
                        blockStatus = false;
                        cout << val2DataItemMap[it.first].value <<  " " << it.second.value << endl;
                        break;
                }
        } else {
                cout << "val key not found" << endl;
        }

      }



      auto end6 = chrono::steady_clock::now();
      val2file << chrono::duration_cast<chrono::microseconds>(end6 - end5).count() << "\n";



/*	
	
	//cout << "validation" << endl;
      // Validation
      std::shared_ptr<TTransport> socket(new TSocket(masterIP, masterPort));
      std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      MasterValidationClient masterValidator(protocol);

      //Logger::instance().log(MSG+" Block "+to_string(block.number) +" connection to master "+WID+" starts", Logger::kLogLevelInfo);
     // while (1) {
          //try {
      transport->open();
           //     break;
          //} catch (exception& e) {
            //    cout << "Val Error: " << e.what() << endl;
          //}
          //}


      //Logger::instance().log(MSG+" Block "+to_string(block.number) +" worker "+WID+" mineBlock() starts", Logger::kLogLevelInfo);

      // sent transaction to execute     
      
      // without sharing info
      cout << "validateBlock starts" << endl;
      cout << block.number << "\t" << block.transactionsList.size() << endl; 
      try{
	masterValidator.validateBlock(block); 
	} catch (exception& e) {
                cout << "Val Error: " << e.what() << endl;
           }

      cout << "validateBlock ends" << endl;

      //Logger::instance().log(MSG+" Block "+to_string(block.number) +" WorkerID "+WID+" mineBlock() ends", Logger::kLogLevelInfo);
      
      transport->close();
      //Logger::instance().log(MSG+" Block "+to_string(block.number) +" connection to master "+WID+" ends", Logger::kLogLevelInfo);

      auto end5 = chrono::steady_clock::now();
      valfile << chrono::duration_cast<chrono::microseconds>(end5 - end4).count() << "\n";

*/

/*

      // with sharing info      

      std::shared_ptr<TTransport> socket2(new TSocket(masterIP, masterPort2));
      std::shared_ptr<TTransport> transport2(new TBufferedTransport(socket2));
      std::shared_ptr<TProtocol> protocol2(new TBinaryProtocol(transport2));
      MasterValidationClient masterValidator2(protocol2);

      //Logger::instance().log(MSG+" Block "+to_string(block.number) +" connection to master "+WID+" starts", Logger::kLogLevelInfo);
      //while (1) {
      //    try {
                transport2->open();
       //         break;
        //  } catch (exception& e) {
          //      cout << "Val2 Error: " << e.what() << endl;
         // }
          //}


      //Logger::instance().log(MSG+" Block "+to_string(block.number) +" worker "+WID+" mineBlock() starts", Logger::kLogLevelInfo);

      // sent transaction to execute     
      
      // with sharing info
      cout << "validateBlockWithInfo starts" << endl;
      cout << "size at master: " << block.sendTxnMap.size() << endl;

	try {
      	masterValidator2.validateBlockWithInfo(block);
	} catch (exception& e) {
                cout << "Val2 Error: " << e.what() << endl;
           }

      cout << "size at master after execution: " << block.sendTxnMap.size() << endl;
	cout << "validateBlockWithInfo ends" << endl;
      // with sharing info

      //Logger::instance().log(MSG+" Block "+to_string(block.number) +" WorkerID "+WID+" mineBlock() ends", Logger::kLogLevelInfo);
      
      transport2->close();
      

      auto end6 = chrono::steady_clock::now();
      val2file << chrono::duration_cast<chrono::microseconds>(end6 - end4).count() << "\n";
	
*/	
     

      clear_memory_miner(); 
      clear_memory_val();
      

      //std::this_thread::sleep_for(std::chrono::milliseconds(1000));
      //e2efile.close(); 

      /*
      struct DataItem {
  //1: required string address;
  1: required double value;
  2: required string owner;
  3: required map<string,double> balances;
  4: required map<string,map<string,double>> allowed;
  5: required map<i64,i64> votes;
  6: required list<Transaction> transactions;
  7: required map<string,PlayerRoll> playerRolls;
  //2: optional map<string,allowedMap> file1; // allowed map file <filename, allowedMap struct>
  //3: optional map<string,balanceMap> file2; // balance map file <filename, balanceMap struct>
  //4: optional map<string,string> file3; // owner file <filename, owner name>
}
      */
      /*
      if (block.number % 100 == 0) {
        ofstream nextState;
        if (NUM_WORKERS == 1)
          nextState.open("state/"+to_string(NUM_WORKERS)+"_worker/block_"+to_string(block.number)+"_next_state.csv",std::ofstream::out | std::ofstream::trunc);
        else 
          nextState.open("state/"+to_string(NUM_WORKERS)+"_workers/block_"+to_string(block.number)+"_next_state.csv",std::ofstream::out | std::ofstream::trunc);
        for (auto it : dataItemMap)
        {
          nextState << it.first << "," << it.second.value << "," << it.second.owner << ","; 
          for (auto b: it.second.balances) {
            nextState << b.first << "," << b.second << ",";
          }
          for (auto a: it.second.allowed) {
            nextState << a.first << ","; //<< b.second << ",";
            for (auto c: a.second) {
              nextState << c.first << "," << c.second << ",";
            }
          }
          for (auto v: it.second.votes) {
            nextState << v.first << "," << v.second << ",";
          }
          for (auto tx: it.second.transactions) {
            nextState << tx << ","; //<< v.second << ",";
          }
          for (auto p: it.second.playerRolls) {
            nextState << p.first << "," << p.second << ",";
          }
          nextState << endl;
        }
        nextState.close();
      
      }*/

    }
    
    txnfile.close();
    e2efile.close();
    minefile.close();
    valfile.close();
    val2file.close();
  }

  void recvMiningStatus(const int64_t nonce, const int32_t number) {
    // Your implementation goes here

    //Logger::instance().log("Block " + to_string(block.number) + " recvMiningStatus starts ", Logger::kLogLevelInfo);
    //cout << "\n" << newBlock.number << "\t" << number << "\t" << minerStatus << endl;
    cout << number << "\t" << nonce << endl;
    if (block.number == number && !minerStatus) {
      minerStatus = true;
	cout << number << "\t" << nonce << endl;
	block.nonce = nonce;
      
      string block_str = convert_block_to_string(block);
      prevBlockHash = sha256(block_str);
      //cout << nonce << "\t" << block_hash << endl;

      //minerStatus = true;
    }
    //cout << "nonce at master: " << block.nonce << endl;
    
    //Logger::instance().log("Block " + to_string(block.number) + " recvMiningStatus ends ", Logger::kLogLevelInfo);
    
    //printf("recvMiningStatus\n");
  }

};

int main(int argc, char **argv) {
  //Logger::instance().log(MSG+" starts", Logger::kLogLevelInfo);
  
  int port = atoi(argv[1]);
  NUM_THREADS = atoi(argv[2]);
  filename = argv[3];
  dir_path = argv[4];
  mining = stoi(argv[5]);
  NUM_WORKERS = NUM_THREADS;

  ::apache::thrift::stdcxx::shared_ptr<MasterServiceHandler> handler(new MasterServiceHandler());
  ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new MasterServiceProcessor(handler));
  ::apache::thrift::stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::apache::thrift::stdcxx::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());
  
  // using thread pool with maximum 15 threads to handle incoming requests
  shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(15);
  shared_ptr<PosixThreadFactory> threadFactory = shared_ptr<PosixThreadFactory>(new PosixThreadFactory());
  threadManager->threadFactory(threadFactory);
  threadManager->start();
  
  //Logger::instance().log(MSG+" creating TThreadPoolServer connection", Logger::kLogLevelInfo);
  //TNonblockingServer server(processor, protocolFactory, nbServerTransport, threadManager);
  
  //TSimpleServer 
  TThreadPoolServer server(processor, serverTransport, transportFactory, protocolFactory, threadManager);
  //Logger::instance().log(MSG+" connection established", Logger::kLogLevelInfo);
  
  //Logger::instance().log(MSG+" service starts", Logger::kLogLevelInfo);
  server.serve();
  //Logger::instance().log(MSG+" service ends", Logger::kLogLevelInfo);
  return 0;
}
