// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/MasterService.h"
#include "gen-cpp/WorkerService.h"
#include "gen-cpp/SharedService.h"

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/Exception.h>
#include <thrift/transport/PlatformSocket.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>

#include <iostream>
#include <pthread.h>
#include <cstdlib>
#include <vector>
#include <random>
#include <functional> //for std::function
#include <algorithm>  //for std::generate_n

#define NUM_WORKERS 5
#define NUM_THREADS 5
#define NUM_ACCOUNTS 50
#define NUM_TRANSACTIONS 10

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace apache::thrift::concurrency;
using namespace ::apache::thrift::server;

using namespace  ::MasterService;
using namespace  ::WorkerService;
using namespace  ::SharedService;

vector<WorkerNode> WorkerList;
vector<Transaction> TransactionList;
vector<Account> AccountList;
map<string,int32_t> DataItemsMap;
map<int16_t, map<set<string>,set<int16_t>>> GlobalConflictsMap; // map<list<addresses>, list<txid>>
map<string,list<int16_t>> LocalConflictsMap; // map<address,list<txid>>

map<string,list<string>> AdjacencyMap;



struct thread_data {
   int16_t  threadID;
   int16_t workerID;
   string workerIP;
   int32_t workerPort;
};


map< string,map< int32_t, vector< int16_t > > > LocalDataItemsMap;
map< int16_t, map< string, map< int32_t, vector< int16_t > > > > GlobalDataItemsMap;
map<int16_t, vector<Transaction>> sendTransactionMap;



typedef std::vector<char> char_array;
 
//we don't want a global. That's ugly.
//This will get optimized at compile time anyway
//http://e...content-available-to-author-only...a.org/wiki/Return_value_optimization
char_array charset()
{
    //Change this to suit
    return char_array( 
  {'0','1','2','3','4',
  '5','6','7','8','9',
  'A','B','C','D','E','F',
  'G','H','I','J','K',
  'L','M','N','O','P',
  'Q','R','S','T','U',
  'V','W','X','Y','Z',
  'a','b','c','d','e','f',
  'g','h','i','j','k',
  'l','m','n','o','p',
  'q','r','s','t','u',
  'v','w','x','y','z'
  });
};    
 
std::string random_string( size_t length, std::function<char(void)> rand_char )
{
    std::string str(length,0);
    std::generate_n( str.begin(), length, rand_char );
    return str;
}

void generateAccounts () {
  const auto ch_set = charset();
  std::default_random_engine rng(std::random_device{}()); 
  std::uniform_int_distribution<> dist(0, ch_set.size()-1);
  auto randchar = [ ch_set,&dist,&rng ](){return ch_set[ dist(rng) ];};
  auto length = 10;

  std::random_device dev;
  std::mt19937 rng1(dev());
  std::uniform_int_distribution<std::mt19937::result_type> dist1(500,1000);

  for (int i=0; i<NUM_ACCOUNTS; i++) {
    Account account;
    account.address = random_string(length,randchar);
    account.amount = dist1(rng1);
    //printf("%s,%d\n", account.address,account.amount);
    cout << account.address << "\t" << account.amount << endl;
    AccountList.push_back(account);
    DataItemsMap[account.address] = account.amount;
  }
}

void generateTransactions () {
  Transaction transaction;
  std::vector<string> Addresses;

  for (auto const& account: AccountList){
    Addresses.push_back(account.address);
  }

  std::random_device dev;
  std::mt19937 rng(dev());
  std::uniform_int_distribution<std::mt19937::result_type> dist(1,50);

  std::random_device random_device;
  std::mt19937 rng1{random_device()};
  std::uniform_int_distribution<int> dist1(0, Addresses.size() - 1);

  for (int i=0; i< NUM_TRANSACTIONS; i++) {
    int senderIndex = dist1(rng1);
    int receiverIndex = dist1(rng1);
    while (senderIndex == receiverIndex) {
      senderIndex = dist1(rng1);
      receiverIndex = dist1(rng1);
    }
    transaction.transactionID = i+1;
    transaction.senderAddress = Addresses[senderIndex];
    transaction.receiverAddress = Addresses[receiverIndex];
    transaction.amount = dist(rng);

    cout << transaction.transactionID << "\t" << transaction.senderAddress << "\t" << transaction.receiverAddress << "\t" << transaction.amount << endl;
    TransactionList.push_back(transaction);
  }
}


map<int16_t, set<string>> ccAddressMap;
map<int16_t, set<int16_t>> ccTransactionMap;

void DFSUtil (int ccID, string v, map<string,bool> &visited) {
  // Mark the current node as visited and print it
  visited[v] = true;
  //cout << v << " ";
  if (LocalConflictsMap[v].size() > 0)
  {
    cout << v << " ";
    ccAddressMap[ccID].insert(v);
  }
  for (auto const& tx: LocalConflictsMap[v])
    ccTransactionMap[ccID].insert(tx);
  // Recur for all vertices
  // adjacent to this vertex
  
  for (auto const& vc: AdjacencyMap[v]) {
    if (!visited[vc]) {
      DFSUtil(ccID,vc,visited);
    }
  }
}

// use list<Transaction>
void analyze() {
  for (auto const& tx: TransactionList) {
    LocalConflictsMap[tx.senderAddress].push_back(tx.transactionID);
    LocalConflictsMap[tx.receiverAddress].push_back(tx.transactionID);
    AdjacencyMap[tx.senderAddress].push_back(tx.receiverAddress);
    AdjacencyMap[tx.receiverAddress].push_back(tx.senderAddress);
  }

  /*
  cout << "Displaying AdjacencyMap" << endl;
  for (std::map<string,list<string>>::iterator i = AdjacencyMap.begin(); i != AdjacencyMap.end(); ++i) {
    cout << i->first << "-->";
    for (auto const& v2: i->second) {
      cout << v2 << ", ";
    }
    cout << endl;
  }
  */

  map<string,bool> visited;

  // Mark all vertices as not visited
  for (auto const& account: AccountList) {
    visited[account.address] = false;
  }
  int ccID = 1;
  for (auto const& account: AccountList) {
    if (visited[account.address] == false) {
      // print all reachable vertices
      DFSUtil(ccID,account.address,visited);
      map<set<string>, set<int16_t>> tmp;
      if (ccTransactionMap[ccID].size() > 0)
      {
        /* code */
        cout << ccID << " ";
        tmp[ccAddressMap[ccID]] = ccTransactionMap[ccID];    
        GlobalConflictsMap[ccID] = tmp;
        ccID++;
        cout << endl;
      }
      
      
    }
    
  }
}


void *connectWorker (void *threadarg) {
  struct thread_data *worker;
  worker = (struct thread_data *) threadarg;

  cout << "Thread ID : " << worker->threadID ;
  //cout << " Message : " << my_data->message << endl;

  std::shared_ptr<TTransport> socket(new TSocket(worker->workerIP, worker->workerPort));
  std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
  WorkerServiceClient client(protocol);
  
  
  transport->open();
  printf("Sending transactionList to worker nodes\n");
  cout << "Size: " << sendTransactionMap[worker->workerID].size() << endl;
  client.recvTransactions(LocalDataItemsMap,sendTransactionMap[worker->workerID]); // returns local conflicts
  for (auto const& tx: sendTransactionMap[worker->workerID]) {
    cout << tx.transactionID << "\t";
  }
  GlobalDataItemsMap[worker->workerID] = LocalDataItemsMap;
  cout <<  "GlobalDataItemsMap size: " << GlobalDataItemsMap[worker->workerID].size() << endl;
  printf("\nclosing transport at Master\n\n");
  transport->close();
  //sleep(5);
  //pthread_exit(NULL);
}

class MasterServiceHandler : virtual public MasterServiceIf {
 public:
  MasterServiceHandler() {
    // Your initialization goes here
    
    int port = 9091;
    string ip = "localhost";

    for (int id=1; id<=NUM_WORKERS; id++) {
      WorkerNode workerNode;
      workerNode.workerID = id;
      workerNode.workerIP = ip;
      workerNode.workerPort = port++;

      WorkerList.push_back(workerNode);
    }

  }

  
  void bcastGlobalDataItems() {
    // Your implementation goes here
    cout << "bcast starts" << endl;
    
    int i=0;
    int rc;
    for (auto const& worker : WorkerList) {
    
      std::shared_ptr<TTransport> socket(new TSocket(worker.workerIP, worker.workerPort));
      std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      WorkerServiceClient client(protocol);

      transport->open();
      cout << "Sending Global Data Items Map to " << worker.workerID << endl;
      client.recvGlobalDataItems(DataItemsMap);
      transport->close();
    }
    printf("bcast ends\n");
  }


  void sendTransactions() {
    // Your implementation goes here
    cout << "Finding global conflicts in transactions" << endl;
    analyze();
    cout << endl;
    cout << "Sending global conflict map transactions to worker nodes" << endl;
    
    

    
    // worker id 
    int id = 0;
    // declaring map used to transfer transactions
    cout << "Preparing Transactions set to be sent to worker nodes" << endl << endl;
    for (std::map<int16_t,map<set<string>,set<int16_t>>>::iterator i = GlobalConflictsMap.begin(); i != GlobalConflictsMap.end(); ++i)
    {
      cout << id << "\t";  
      cout << i->first << "\t";
      for (std::map<set<string>,set<int16_t>>::iterator j = i->second.begin(); j != i->second.end(); ++j)
      {
        cout << "\n";
        // Data items List
        for (auto const& k:j->first) {
          cout << k << "\t";
        }
        cout << "\n";
        
        // Transactions List
        // set to vector conversion
        for (auto const& k:j->second) {
          cout << k << "\t";
          sendTransactionMap[WorkerList[id].workerID].push_back(TransactionList[k-1]);
        }
        cout << "\n";        
      }

      cout << endl; 
      //printf("closing transport at Master\n");
      //transport->close();
      id = (id + 1) % NUM_WORKERS;
    }

    cout << endl;
    
    pthread_t threads[NUM_THREADS];
    pthread_attr_t attr;
    struct thread_data td[NUM_THREADS];
    int rc;
    int thID = 0;
    void *status;

    // Initialize and set thread joinable
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

    for (auto const& worker : WorkerList) {
      cout <<"sendTransactions() : creating thread, " << thID << endl;
      td[thID].threadID = thID;
      td[thID].workerID = worker.workerID;
      td[thID].workerIP = worker.workerIP;
      td[thID].workerPort = worker.workerPort; 
      rc = pthread_create(&threads[thID], &attr, connectWorker, (void *)&td[thID]);
      
      if (rc) {
         cout << "Error:unable to create thread," << rc << endl;
         exit(-1);
      }
      thID++;
    }
    
    // free attribute and wait for the other threads
    //pthread_attr_destroy(&attr);
    int i;
    for( i = 0; i < NUM_THREADS; i++ ) {
      rc = pthread_join(threads[i], &status);
      if (rc) {
         cout << "Error:unable to join," << rc << endl;
         exit(-1);
      }
      
      cout << "Main: completed thread id :" << i ;
      cout << "  exiting with status :" << status << endl;
   }

   cout << "sendTransactions(): program ends " << endl;
   //pthread_exit(NULL);
    map< int16_t, map< string, map< int32_t, vector< int16_t > > > >::iterator itr;

    for (itr = GlobalDataItemsMap.begin(); itr != GlobalDataItemsMap.end(); ++itr) { 
      cout << "Worker ID:" << itr->first << '\n';
      map<string,map< int32_t, vector<int16_t>>>::iterator itr2;
      for (itr2 = itr->second.begin(); itr2 != itr->second.end(); ++itr2) {
        cout << itr2->first << "\t";
        for (std::map< int32_t, vector<int16_t>>::iterator itr3 = itr2->second.begin(); itr3 != itr2->second.end(); ++itr3)
        {
          cout << "Transaction Order: ";
          for (auto const& txID: itr3->second) {
            cout << txID << "\t";
          }
          cout << "Value: " << itr3->first << "\t";
          
          cout << endl;
        }
        cout << endl;
      }
      cout << endl;
    }

    printf("sendTransactions\n");
    //pthread_exit(NULL);

    // Update the final state and save transactions order
    // Create Block
    // flush all the in memory structures required to create block
    // send block for validation
    // add block to blockchain
    // start new block generation process
    
  }

};

int main(int argc, char **argv) {
  int port = atoi(argv[1]);
  ::apache::thrift::stdcxx::shared_ptr<MasterServiceHandler> handler(new MasterServiceHandler());
  ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new MasterServiceProcessor(handler));
  ::apache::thrift::stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::apache::thrift::stdcxx::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  printf("Creating %d accounts\n", NUM_ACCOUNTS);
  generateAccounts();
  printf("Creating %d transactions\n",NUM_TRANSACTIONS);
  generateTransactions();

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

  server.serve();
  return 0;
}